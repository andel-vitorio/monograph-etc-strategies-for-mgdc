\chapter{Definição e Resolução de Problemas de Otimização por meio de LMIs}\label{apendiceB}

\subsection{Obtenção dos Parâmetros de Projeto do \acrshort{etm}}

O código \ref{cod:params_etm} aborda a resolução do problema de minimização estabelecido em \eqref{eq:optimization_problem} que busca aumentar o intervalo de tempo entre os eventos. Através desta abordagem, busca-se determinar os valores ótimos dos parâmetros $\Xi$ e $\Psi$, que são essenciais para determinar o momento de acionamento de um evento, além do ganho $K$ utilizado no controle em malha fechada.

\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Resolução do problema de otimização definida em \eqref{eq:optimization_problem}.}, label=cod:params_etm]
  # Definição dos parâmetros do problema de otimização
  A = cp.Parameter((2, 2),
                   value=np.array([[A11, A12], [A21, A22]]))
  BU = cp.Parameter((2, 1), value=np.array([[B11], [B21]]))
  I = cp.Parameter((2, 2), name='I', value=np.identity(2))
  
  # Definição das variáveis do problema de otimização
  Q = cp.Variable((2, 2), name='Q', PSD=True)
  X = cp.Variable((2, 2), name='X', PSD=True)
  Ξ_TIL = cp.Variable((2, 2), name='Ξ_TIL', PSD=True)
  Ψ_TIL = cp.Variable((2, 2), name='Ψ_TIL', PSD=True)
  K_TIL = cp.Variable((1, 2), name='K_TIL')
  
  # Definição do problema: objetivo e restrições
  obj = cp.Minimize(cp.trace(Ξ_TIL + Ψ_TIL + Q))
  
  M11 = A @ X + BU @ K_TIL + X @ A.T + K_TIL.T @ BU.T
  M12 = BU @ K_TIL
  M13 = X
  
  M21 = K_TIL.T @ BU.T
  M22 = -Ξ_TIL
  M23 = np.zeros(shape=(2, 2))
  
  M31 = X
  M32 = np.zeros(shape=(2, 2))
  M33 = -Ψ_TIL
  
  M = cp.bmat([[M11, M12, M13],
               [M21, M22, M23],
               [M31, M32, M33]])
  
  N11 = -Q
  N12 = I
  N21 = I.T
  N22 = -X
  N = cp.bmat([[N11, N12],
               [N21, N22]])
  
  constraints = [M << 0, N << 0]
  prob = cp.Problem(obj, constraints)
  
  # Resolução do problema usando o solver MOSEK
  prob.solve(solver=cp.MOSEK, verbose=False)
  
  K = None
  Ξ = None
  Ψ = None
  P = None
  
  # Apresentação dos Resultados
  if prob.status not in ["infeasible", "unbounded"]:
    X_INV = np.linalg.inv(X.value)
    Ξ = X_INV @ Ξ_TIL.value @ X_INV
  
    _K = K_TIL @ X_INV
    K = _K.value
  
    Ψ = np.linalg.inv(Ψ_TIL.value)
    P = X_INV
\end{lstlisting}

Inicialmente, são estabelecidos os parâmetros do problema de otimização, em que \texttt{A} representa a matriz de estados e \texttt{BU}, a matriz de entrada controlável, isto é, o duty cycle. Ambas são formadas utilizando os elementos previamente definidos na subseção anterior, \ref{subsection:implementation_of_linear_models}. Além disso, é definida a matriz identidade $I_2$, representada por \texttt{I}, uma vez que tanto o sistema Buck quanto o Boost possuem dois estados. Em seguida, as variáveis do problema são definidas. São elas: $Q$, $X$, $\tilde{\Xi}$, $\tilde{\Psi}$, todas matrizes semidefinidas positivas indicadas por \texttt{PSD=True}, e $\tilde{K}$, conforme definido em \eqref{eq:optimization_problem}.

Após a definição dos parâmetros e das variáveis do problema, o objetivo, representado por \texttt{obj}, é estabelecido. Ele é construído utilizando a função \texttt{Minimize} da biblioteca CVXPY, indicando que se trata de um problema de minimização. Como argumento, esta função recebe o que deve ser minimizado, sendo o traço da soma das matrizes $\tilde{\Xi}$, $\tilde{\Psi}$ e $Q$, como definido em \eqref{eq:optimization_problem}. O traço é calculado através da função \texttt{trace}, também da biblioteca CVXPY. Logo após, as restrições do problema são definidas, onde a variável \texttt{M} representa a \acrshort{lmi} de restrição conforme \eqref{eq:constraints_1}, e \texttt{N} representa a segunda \acrshort{lmi} de restrição, como definido em \eqref{eq:constraints_2}. Ambas são construídas utilizando a função \texttt{bmat} do CVXPY, que gera blocos de matrizes. O operador \texttt{<<}, pertencente à biblioteca CVXPY, indica que as matrizes são semidefinidas negativas, conforme determinado nas \acrshortpl{lmi} de restrição.

Por fim, o problema é criado e representado por \texttt{prob}, utilizando a função \texttt{Problem}, que recebe dois parâmetros: o objetivo e as restrições previamente definidos. Em seguida, o problema é resolvido pelo solucionador MOSEK, utilizando o método \texttt{solve} da variável \texttt{prob}. Após a conclusão da resolução, é verificado se o problema é factível. Se for o caso, os parâmetros $\Psi$, $\Xi$, $K$ e $P$ do projeto do \acrshort{etm} são obtidos.
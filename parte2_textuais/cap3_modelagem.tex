\chapter{Conversores CC com Cargas de Potência Constante} \label{cap3}

\section{Microrredes de Corrente Contínua}

No século XX, a "Guerra das Correntes" entre defensores da \acrshortpl{ca}, liderados por \textit{Westinghouse} e \textit{Tesla}, e proponentes da \acrshort{cc}, liderados por \textit{Edison}, resultou na prevalência da \acrshort{ca} devido à sua facilidade de expansão da rede. Apesar disso, a \acrshort{cc} permaneceu relevante com os avanços na eletrônica de potência. Paralelamente, a crescente adoção de microrredes \acrshortpl{cc}, com \acrfullpl{fer}, \acrfullpl{sae} e novas cargas, reflete das preocupações ambientais e escassez de combustíveis fósseis, mas sua integração descoordenada apresenta desafios técnicos e operacionais, como perfil de tensão comprometido e congestionamentos nas linhas de transmissão. \cite{Elsayed2015, Dragicevic2015}.

A proposta das \acrshortpl{mr} surgiu como uma solução há mais de uma década. As \acrshortpl{mr} operando em modo isolado ou conectadas à rede, podem ser classificadas como \acrshortpl{mr} de \acrshort{ca} ou \acrshort{cc}. Devido à sua maior eficiência e melhor interface com diversos tipos de \acrshort{fer} e \acrshort{sae}, a s\acrshortpl{mr} de \acrshort{cc}, cuja estrutura básica está representada na \autoref{fig:microgrid}, é mais atraente. Além disso, ao serem acopladas em torno de um barramento \acrshort{cc}, as \acrshortpl{mr} eliminam problemas como fluxo de potência reativa e regulação de frequência, resultando em sistemas de controle menos complexos. \cite{Dragicevic2015}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.87\textwidth]{figuras/microgrid.eps}
  \caption{Estrutura básica de uma microrrede.}
  \label{fig:microgrid}
\end{figure}

Vários setores empregam \acrfullpl{sdcc}, como espaçonaves, centros de dados, telecomunicações, tração e sistemas de energia a bordo de navios. Por exemplo, a Estação Espacial Internacional utiliza \acrshortpl{sdcc} para operar suas vastas necessidades de energia. Alguns centros de dados também adotaram sistemas \acrshort{cc}, resultando em economia significativa de energia em comparação com sistemas \acrshort{ca} tradicionais. Na área de telecomunicações, os sistemas de distribuição de energia de 48V são amplamente empregados para garantir alta confiabilidade e eficiência. Além disso, sistemas de tração, como bondes e metrôs, preferem distribuição \acrshort{cc} devido à facilidade de interface com motores \acrshort{cc}. Esses sistemas também permitem maior eficiência e controlabilidade. Em sistemas de energia a bordo de navios, a distribuição zonal \acrshort{cc} é uma opção popular devido à sua confiabilidade e facilidade de proteção. \cite{Elsayed2015}.

Desta forma, o design de sistemas de distribuição \acrshort{cc} tem recebido atenção crescente, especialmente devido a adaptação de equipamentos projetados originalmente para \acrshort{ca}. Modelos simplificados são essenciais para compreender o comportamento da carga em operação \acrshort{cc}. Comparando configurações de cabos, descobriu-se que sistemas \acrshort{cc} podem superar \acrshort{cc} em termos de capacidade de transferência de energia, \cite{Salomonsson2007}. Em um estudo sobre microrredes \acrshort{cc} em centros de dados, \cite{Salomonsson2008}, foi proposto um sistema de controle adaptativo para otimizar o fluxo de energia e minimizar perdas. Essas pesquisas contribuem para uma compreensão mais profunda do design e controle de sistemas de distribuição DC.

% MR: Conversores e CPLs - Introdução
Os conversores \acrshort{cc}-\acrshort{cc} são dispositivos bastante utilizados para regular a tensão nas \acrshortpl{mr} \acrshort{cc}, facilitando a integração de fontes de energia renovável e tradicional. Contudo, grande quantidades de conversores conectados nas \acrshortpl{mr} \acrshort{cc} pode afetar a estabilidade do sistema. Além disto, estes conversores podem energizar \acrfullpl{cpl}, cujo circuito equivalente está descrito na figura a seguir:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{figuras/cpl_circuit.eps}
  \caption{Circuito simplificado de uma CPL.}
  \label{fig:cpl_circuit}
\end{figure}

\noindent A partir deste circuito, pode-se derivar a seguinte equação dinâmica: \begin{equation} i_{\text{CPL}}(t) = i_R(t) + I_{\text{CPL}} = \frac{P_{\text{CPL}}}{(v_{\text{CPL}}(t))^2} + I_{\text{CPL}} \label{eq:cpl-circuit},\end{equation} onde $P_{\text{CPL}}$ representa a potência da \acrshort{cpl}. Ao linearizar a equação dinâmica \eqref{eq:cpl-circuit} em torno do ponto de operação $P_0$ para a potência da \acrshort{cpl} e $V_0$ para a tensão da \acrshort{cpl}, pode-se obter a seguinte expressão: \begin{equation} \delta i_{\text{CPL}}(t) = - \frac{P_0}{{V_0}^2}\delta v_{\text{CPL}}(t) + I_{\text{CPL}}. \end{equation} Considerando que $\frac{1}{R_0} = - \frac{P_0}{{V_0}^2}$, é possível observar a presença de uma impedância negativa e, da equação \eqref{eq:cpl-circuit}, a não linearidade da \acrshort{cpl}. Estas característica podem causar oscilações indesejadas que podem causar instabilidade e colapso do sistema das \acrshortpl{mr}. \cite{Bessa2020, Amiri2020}.

% MR: Soluções Propostas
Para resolver esses problemas, foram propostas várias técnicas de controle, incluindo filtros RL ou RC, controle preditivo, técnicas robustas, o uso de resistência virtual e métodos de controle não lineares, como controle de modo deslizante e controle preditivo de modelo. O desenvolvimento de controladores robustos e observadores de distúrbios é comum para manter a estabilidade, com o método de backstepping considerado particularmente eficaz. No entanto, desafios adicionais surgem devido à incerteza nos parâmetros do conversor e distúrbios associados aos \acrshortpl{cpl}, exigindo abordagens mais sofisticadas de controle e análise de estabilidade. \cite{Bessa2020, Amiri2020}.

\section{Conversores \acrshort{cc}-\acrshort{cc}}

Os conversores \acrshort{cc}-\acrshort{cc} são circuitos que transferem energia elétrica de uma fonte de entrada para uma de saída. Estes conversores operam por meio de semicondutores que atuam como interruptores, controlando o fluxo de energia através de elementos passivos, como indutores e capacitores. O variável fundamental para determinar a operação do conversor é a razão cíclica, ou ciclo de trabalho, que define a proporção de tempo em que os interruptores permanecem ligados e desligados. Entre as diversas topologias de conversores \acrshort{cc}-\acrshort{cc}, destacam-se os conversores Buck e Boost, que serão abordados neste trabalho.

\subsection{Conversor Buck} \label{section:buck_converter}

% Buck: Introdução
O conversor \acrshort{cc}-\acrshort{cc} abaixador de tensão, mais conhecido como conversor Buck, produz uma tensão de saída média menor que a entrada. Isso ocorre devido à conservação de energia, resultando em uma corrente de saída média maior que a corrente de entrada média. Teoricamente, o conversor Buck permite uma variação contínua da tensão na carga, de zero até a tensão de entrada. \cite{martins2008}.

% Buck: Configuração Básica
A configuração básica do conversor Buck é apresentada na \autoref{fig:basic-buck-converter}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.27\textwidth]{figuras/basic_buck_conversor.eps}
  \caption{Configuração básica do conversor Buck.}
  \label{fig:basic-buck-converter}
\end{figure}

% Buck: Valor médio de tensão
O valor médio da tensão da carga, $\bar{v}_{out}$ é descrito como: \begin{equation} \bar{v}_{out} = \frac{t_c}{T}v_{in}, \end{equation} onde, $t_c$ é o tempo em que a chave $S$ permanece fechada, $t_a$ é o tempo em que a chave permanece aberta, e $T = t_c + t_a$ é o período de chaveamento. \cite{martins2008}.

% Buck: parâmetros do circuito
A razão cíclica, ou duty cycle, é definida como: \begin{equation} d = \frac{t_c}{T}. \end{equation} Logo, obtêm-se a característica de transferência do conversor Buck: \begin{equation} \bar{v}_{out} = dv_{in}. \label{eq:buck_feature}\end{equation} A partir desta equação, pode-se definir a corrente média: \begin{equation} \bar{i} = d\frac{v_{in}}{R}. \end{equation} E por fim, a potência de entrada é dada pela expressão: \begin{equation} P_{in} = d \frac{v_{in}^2}{R}. \end{equation}

% Buck: linearidade
A partir da equação \eqref{eq:buck_feature}, pode-se observar que a tensão média sobre a carga é diretamente linear a tensão de entrada, cuja taxa de variação é igual ao valor do duty cycle $d$. Isto possibilita o controle da tensão média sobre a carga por meio da razão cíclica. Tal controle pode ser através da variação do tempo de condução $t_c$ da chave $S$. Desta forma, para $t_c = 0 \Rightarrow d = 0$ e $t_c = T \Rightarrow d = 1$, que representam a chave permanentemente aberta e fechada, respectivamente. Assim, a potência transferida à carga pode ser controlada, variando a sua tensão média entre 0 e $v_{in}$. \cite{martins2008}.

% Buck: buck com carga RLE - introdução
Para uma análise mais abrangente, é relevante mencionar o conversor Buck que alimenta uma carga RLE composta por resistor, indutor e uma fonte de tensão, conforme apresentado na \autoref{fig:buck_converter_rle}. No entanto, é crucial entender que uma fonte de tensão só pode ser conectada a uma carga com características de fonte de corrente. Isso implica que uma carga que se comporte como uma fonte de tensão deve ser associada em série com um indutor para refletir o comportamento de uma fonte de corrente. Além disso, é importante destacar que interromper abruptamente uma fonte de corrente, ou uma carga com tais características, não é permitido. Em situações onde essa operação é necessária, como em sistemas de eletrônica de potência, utiliza-se um diodo em antiparalelo com a fonte (ou carga) que será interrompida. \cite{martins2008}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.33\textwidth]{figuras/buck_converter_rle.eps}
  \caption{1ª Etapa}
  \label{fig:buck_converter_rle}
\end{figure}

% Buck: buck com carga RLE - funcionamento
Considerando essas premissas, podemos analisar as fases de funcionamento do conversor Buck ao alimentar uma carga RLE. Na primeira fase, ilustrada na \autoref{fig:buck_converter_rle_s1}, a chave do conversor está fechada, permitindo que a corrente da carga flua da fonte para a carga, o que representa a transferência de energia da fonte para a carga. Na próxima fase, ilustrada na \autoref{fig:buck_converter_rle_s2}, a chave é aberta, e a corrente da carga é direcionada através do diodo, marcando a fase de roda livre do conversor. A falta do diodo nessa fase poderia resultar em tensões prejudiciais sobre a chave do conversor durante a transição entre as fases de operação. \cite{martins2008}.

\begin{figure}[H]
  \captionsetup{justification=centering}
  \centering
  \begin{subfigure}[t]{0.33\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figuras/buck_converter_rle_s1.eps}
    \caption{1ª Etapa}
    \label{fig:buck_converter_rle_s1}
  \end{subfigure}
  \hfil
  \begin{subfigure}[t]{0.33\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figuras/buck_converter_rle_s2.eps}
    \caption{2ª Etapa}
    \label{fig:buck_converter_rle_s2}
  \end{subfigure}
  \caption{Etapas de funcionamento do conversor Buck com carga RLE. As linhas tracejadas indicam que a corrente no ramo é nula.}
\end{figure}

% Buck: Filtros
A corrente proveniente da fonte que alimenta o conversor Buck tem uma natureza pulsante, o que resulta em dois inconvenientes significativos. Em primeiro lugar, a presença de um elevado conteúdo harmônico pode causar perturbações radioelétricas, potencialmente interferindo com equipamentos de comunicação e sinalização. Além disso, caso haja indutância em série com a fonte, mesmo que seja de natureza parasitária, no momento da abertura da chave, podem ser geradas sobretensões potencialmente destrutivas para os semicondutores de potência. Para superar essas dificuldades, recomenda-se a implementação de um filtro LC ou RLC, como ilustrado na \autoref{fig:buck_with_current_filter}. Em casos onde um conversor Buck precisa fornecer uma saída com uma tensão contínua de baixa ondulação, é essencial incluir um filtro passa-baixa composto por um indutor e um capacitor, conforme ilustrado na \autoref{fig:buck_with_voltage_filter}. \cite{martins2008}.

\begin{figure}[H]
  \captionsetup{justification=centering}
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figuras/buck_with_current_filter.eps}
    \caption{Filtragem da corrente de entrada}
    \label{fig:buck_with_current_filter}
  \end{subfigure}
  \hfil
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figuras/buck_with_voltage_filter.eps}
    \caption{Filtragem da tensão de saída.}
    \label{fig:buck_with_voltage_filter}
  \end{subfigure}
  \caption{Conversor Buck com filtros.}
\end{figure}

\subsection{Conversor Boost}

% Boost: Introdução
O conversor \acrshort{cc}-\acrshort{cc} de elevação de tensão, conhecido como conversor Boost, tem sua tensão média de saída teoricamente equivalente à tensão de alimentação. Embora sua estrutura utilize uma quantidade semelhante de componentes ao conversor Buck, estes são reorganizados para formar uma nova topologia. Essa configuração envolve a adição de uma indutância em série com a fonte de alimentação, transformando-a em uma fonte de corrente. Consequentemente, a carga deve ser projetada para se comportar como uma fonte de tensão, conforme as premissas estabelecidas anteriormente. \cite{martins2008}.

% Boost: Estrutura básica
A \autoref{fig:basic_boost_converter_a} apresenta a estrutura básica do conversor Boost. Em altas frequências de chaveamento, a corrente de entrada pode ser considerada constante, denotada por $i_{in}$, e o circuito pode ser representado conforme ilustrado na \autoref{fig:basic_boost_converter_b}. \cite{martins2008}.

\begin{figure}[h]
  \centering
  \captionsetup{justification=centering}
  \begin{subfigure}[b]{0.33\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figuras/basic_boost_converter_a.eps}
    \caption{}
    \label{fig:basic_boost_converter_a}
  \end{subfigure}%
  \hfil
  \begin{subfigure}[b]{0.37\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figuras/basic_boost_converter_b.eps}
    \caption{}
    \label{fig:basic_boost_converter_b}
  \end{subfigure}
  \caption{Estrutura básica do conversor Boost.}
  \label{fig:boost_converter}
\end{figure}

% Boost: relação tensão entrada-saída
Considerando que a chave $S$ opera com frequência fixa e duty cycle variável, podemos expressar a energia fornecida pela fonte de entrada $v_{in}$ como: \begin{equation} \mathcal{E}_{in} = v_{in} i_{in} T, \end{equation} E a energia recebida pela carga como: \begin{equation} \mathcal{E}_{out} = v_{out} i_{in} t_a. \end{equation} Portanto, a energia recebida pela carga é dada por: \begin{equation} \mathcal{E}_{out} = v_{out} i_{in} (T - t_c). \end{equation} Considerando o sistema conservativo, isto é, $\mathcal{E}_{in} = \mathcal{E}_{out}$, obtemos: \begin{equation} v_{in} i_{in} T = v_{out} i_{in} (T - t_c). \end{equation} Assim, \begin{equation} \frac{v_{out}}{v_{in}} = \frac{1}{1-d} \label{eq:ideal_feature_boost}.\end{equation} Esta última equação representa a característica ideal de transferência do conversor Boost. Quando o duty cycle $d$ tende a 1, $v_{out}$ tende ao infinito. Além disso, a tensão mínima de saída é igual à tensão de entrada $v_{in}$. \cite{martins2008}.

% Boost: relação corrente entrada-saída
A potência de entrada e saída são definidas da seguinte forma: \begin{align} P_{\text{in}} &= v_{\text{in}} \cdot i_{\text{md}} \\ P_{\text{out}} &= v_{\text{out}} \cdot i_{\text{out}}, \end{align} onde $i_{\text{md}}$ é a corrente média da entrada do conversor Boost. A partir destas equações e considerando que o conversor é conservativo, ou seja, $P_{\text{in}} = P_{\text{out}}$, tem-se: \begin{gather} v_{in} i_{\text{md}} = v_{\text{out}}i_{\text{out}} \\ \frac{i_{\text{out}}}{i_{md}} = \frac{v_{\text{in}}}{v_{\text{out}}} \label{eq:boost_converter_iv} \end{gather}

A partir das equações \eqref{eq:ideal_feature_boost} e \eqref{eq:boost_converter_iv}, a relação entre a corrente média de saída a corrente média de saída pode ser expressa como: \begin{equation} i_{\text{out}} = (1 - d) \cdot i_{\text{in}} \label{eq:boost_converter_current_transfer} \end{equation} e relação entre a tensão de entrada e tensão média de saída como: \begin{equation} v_{\text{out}} = \frac{1}{(1 - d)} \cdot v_{\text{in}}. \label{eq:boost_converter_voltage_transfer}\end{equation}

% Boost: Etapas de funcionamento
O conversor Boost, ilustrado na \autoref{fig:boost_converter}, opera em duas etapas distintas, descritas como segue: na fase inicial $(0, t_c)$, representada na \autoref{fig:boost_converter_s1}, o processo tem início com o fechamento da chave S. Nesse intervalo, o diodo D é polarizado inversamente, isolando o estágio de saída da fonte de alimentação $i_{in}$, que está em curto-circuito. A corrente na chave é equivalente à corrente da fonte de alimentação, enquanto a corrente no diodo D é nula. Essa fase é concluída quando a chave S é aberta. Na segunda etapa $(t_c, T)$, representada na \autoref{fig:boost_converter_s2}, ocorre a condução do diodo D quando a chave S é aberta, permitindo que a fonte de corrente $i_{in}$ entregue energia à carga. Durante esse período, a corrente na chave é nula, e a corrente no diodo D é igual à corrente da fonte de alimentação. O término dessa etapa ocorre com o fechamento da chave S, dando início novamente à primeira etapa. \cite{martins2008}.

\begin{figure}[h]
  \centering
  \captionsetup{justification=centering}
  \begin{subfigure}[b]{0.37\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figuras/boost_converter_s1.eps}
    \caption{Primeira etapa.}
    \label{fig:boost_converter_s1}
  \end{subfigure}%
  \hfil
  \begin{subfigure}[b]{0.37\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figuras/boost_converter_s2.eps}
    \caption{Segunda etapa.}
    \label{fig:boost_converter_s2}
  \end{subfigure}
  \caption{Etapas de funcionamento do conversor Boost. As linhas tracejadas indicam que a corrente é nulo no ramo.}
\end{figure}

% Boost: Capacitor em paralelo com a carga
Como visto anteriormente, a fonte de alimentação $V_{in}$, conectada em série com um indutor $L$, age como uma fonte de corrente. Portanto, a carga deve operar como uma fonte de tensão. Logo, se a carga for indutiva, é necessário conectar em paralelo a ela um capacitor de valor apropriado, conforme ilustrado na figura abaixo. \cite{martins2008}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{figuras/boost_converter_capacitor.eps}
  \caption{Conversor Boost com capacitor em paralelo com a carga.}
  \label{fig:boost_converter_capacitor}
\end{figure}

\section{Modelagem Matemática}

% Modelagem: Introdução
Nesta seção, será discutida a modelagem matemática de conversores Buck e Boost conectados a uma \acrshort{cpl}. O conversor Buck reduz a tensão contínua de alta para baixa, enquanto o conversor Boost a eleva de baixa para alta. A \acrshort{cpl} demanda potência constante, independentemente da tensão de entrada. Desta forma, pode-se obter uma base sólida para análises subsequentes e o desenvolvimento de estratégias de \acrshort{etc}.

\subsection{Conversor Buck}

% Modelagem Buck: Apresentação do circuito
O sistema inicialmente utilizado neste estudo é um conversor constituído por um conversor Buck básico com filtro de tensão de saída $RLC$ conectado a uma \acrshort{cpl}. A \acrshort{cpl} é representada por um resistor e uma fonte de corrente dependente da potência da \acrshort{cpl}, conforme a seguinte equação: \begin{equation} i_{CPL}(t) = \frac{P_{CPL}(t)}{v_{out}(t)} \label{eq:cpl_current} \end{equation} onde $i_{CPL}(t)$ é a corrente da \acrshort{cpl} em função do tempo, a $P_{CPL}(t)$ é a potência da \acrshort{cpl} e $v_{out}(t)$ é a tensão de saída do conversor em função do tempo.

\begin{figure}[H]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[width=0.87\textwidth]{figuras/buck_converter_circuit.eps}
  \caption{Circuito \textit{Buck} com \acrshort{cpl}.}
  \label{fig:circuit1}
\end{figure}

% Modelagem Buck: Corrente do indutor
Conforme abordado na \autoref{section:buck_converter}, a tensão fornecida pelo conversor Buck para o restante do circuito é igual ao produto entre a tensão de entrada $v_{in}$ e o duty cycle $d(t)$. Considerando esta característica e aplicando a \acrfull{lkt} no filtro, obtém-se a seguinte equação: \begin{equation} d(t)v_{in} - L \dt{i}_L - R_L i_L(t) - v_C(t) = 0, \end{equation} onde $i_L$ é corrente no indutor e $v_C$ é a tensão sobre o capacitor. Desta forma, é possível determinar a equação dinâmica da corrente do indutor, que é: \begin{equation} \dt{i}_L = - \frac{R_L}{L} i_L(t) - \frac{1}{L} v_C(t) + \frac{v_{in}}{L}d(t). \label{eq:buck_converter_current} \end{equation}

% Modelagem Buck: Tensão do capacitor
Por meio da \acrfull{lkc}, pode-se definir a corrente do indutor $i_{L}$ como a soma das correntes através do capacitor $C$, da resistência $R_C$ e da \acrshort{cpl}: \begin{equation} i_L(t) = i_C(t) + i_R(t) + i_{CPL}(t). \end{equation} Dessa forma, considerando $i_C(t) = C\dt{v}_C$, $i_R(t) = \frac{v_C(t)}{R_C}$ e $i_{CPL}(t)$ definida em \eqref{eq:cpl_current}, obtém-se: \begin{equation} i_L(t) = C\dt{v}_C + \frac{v_C(t)}{R_C} + \frac{P_{CPL}}{v_C(t)}. \end{equation} Logo, a equação dinâmica da tensão do capacitor é expressa por: \begin{equation} \dt{v}_C = \frac{1}{C} i_L(t) - \frac{1}{CR_C}v_C(t) - \frac{P_{CPL}}{Cv_C(t)} \label{eq:buck_converter_voltage} \end{equation}

% Modelagem Buck: Modelo não-linear
A partir das equações dinâmicas \eqref{eq:buck_converter_current} e \eqref{eq:buck_converter_voltage}, pode-se estabelecer o modelo dinâmico do sistema como segue: \begin{equation}\begin{cases} \dt{i}_L &=  - \frac{R_L}{L} i_L(t) - \frac{1}{L} v_C(t) + \frac{v_{in}}{L}d(t)  \\ \dt{v}_C &= \frac{1}{C} i_L(t) - \frac{1}{C R_C} v_C(t) - \frac{1}{C v_C(t)} P_{CPL}(t) \label{eq:buck_nonlinear_system} \end{cases}, \end{equation} onde $i_L(t)$ e $v_C(t)$ são os estados do sistema, e $d(t)$ e $P_{CPL}(t)$ são as entradas.

\subsection{Conversor Boost}

O segundo sistema utilizada neste estudo consiste em um conversor Boost conectado a uma \acrshort{cpl}, onde um capacitor é adicionado em paralelo, uma vez que a carga é considerada possuir características indutivas. A modelagem da \acrshort{cpl} segue a mesma metodologia do sistema anterior, representando-a por uma fonte de corrente dependente. A Figura \autoref{fig:boost_converter_cpl} ilustra o circuito completo deste sistema para a modelagem.

\begin{figure}[H]
  \centering
  \includegraphics[width=.73\textwidth]{figuras/boost_converter_cpl.eps}
  \caption{Conversor Boost conectado a uma \acrshort{cpl}.}
  \label{fig:boost_converter_cpl}
\end{figure}

Por meio da relação entre a tensão de entrada e a tensão média de saída do conversor Boost, conforme descrito na equação \eqref{eq:boost_converter_voltage_transfer}, e da \acrshort{lkt}, obtém-se: \begin{equation} L \dt{i}_L - \frac{1}{1-d} v_{\text{in}} - v_c(t) = 0. \end{equation} Dessa forma, a equação dinâmica da corrente do indutor é expressa como: \begin{equation} \dt{i}_L = \frac{1}{L}v_{\text{in}} - \frac{1-d}{L}v_C(t) \label{eq:boost_converter_current}. \end{equation}

Ao aplicar a \acrshort{lkc}, temos que a corrente do diodo é igual à soma das correntes do capacitor, do resistor e da corrente $i_{CPL}(t)$, definida em \eqref{eq:cpl_current}. A corrente do diodo é igual à corrente média de saída do conversor Boost, expressa na equação \eqref{eq:boost_converter_current_transfer}. Portanto, \begin{equation} (1 - d) i_{\text{in}}(t) = C\dt{v}_C + \frac{v_C(t)}{R} + \frac{P_{CPL}(t)}{v_C(t)}.\end{equation} Considerando altas frequências de chaveamento, a corrente média de entrada pode ser considerada igual à corrente do indutor. Assim, a equação dinâmica da tensão do capacitor pode ser expressa como: \begin{equation} \dt{v}_C = \frac{1 - d}{C} i_L(t) - \frac{1}{RC}v_C(t) - \frac{1}{Cv_C(t)}P_{CPL}(t). \label{eq:boost_converter_voltage}\end{equation}

Desse modo, o modelo dinâmico médio do segundo sistema pode ser formulado a partir das equações \eqref{eq:boost_converter_current} e \eqref{eq:boost_converter_voltage}. Este modelo é representado por: \begin{equation} \begin{cases} \dt{i}_L(t) = - \frac{1-d(t)}{L}v_C(t) + \frac{1}{L}v_{in} \\ \dt{v}_C(t) = \frac{1 - d(t)}{C} i_L(t) - \frac{1}{RC}v_C(t) - \frac{1}{Cv_C(t)}P_{CPL}(t). \label{eq:boost_nonlinear_system}\end{cases} \end{equation} As grandezas $i_L(t)$ e $v_C(t)$ representam os estados do sistema. Enquanto que $d(t)$ e $P_{CPL}(t)$ representam as entadas do sistema, onde o duty cycle é controlável e a potência da \acrshort{cpl} é considerada a pertubação do sistema.

\subsection{Transladação dos modelos obtidos}

% Transladação: introdução
Para estudo dos sistemas dinâmicos em um ponto de equilíbrio \begin{equation} P_{\text{o}} = \left({i_L}_{\text{o}}, \, {v_C}_{\text{o}}, \, d_{\text{o}}, \, {P_{cpl}}_{\text{o}} \right). \label{eq:operation_point} \end{equation} Ambos os sistemas serão transladados pelo método de mudança de variáveis. As variáveis de estado e as entradas de ambos os sistemas serão decompostas em termos constantes (seus valores no ponto de equilíbrio) e variantes no tempo, conforme apresentado nas equações a seguir: \begin{align}
  {i_L}(t) & = {i_L}_o + \delta i_L(t), & {v_C}(t)     & = {v_C}_o + \delta v_C(t), \label{eq:tranlation_decomposed_states}        \\[12pt]
  {d}(t)   & = d_o + \delta d(t),       & {P_{cpl}}(t) & = {P_{cpl}}_o + \delta P_{cpl}(t) \label{eq:tranlation_decomposed_inputs}
\end{align} Da mesma forma, as derivadas temporais das variáveis de estado também são decompostas: \begin{align}
  \dt{i}_L = {\dt{i_L}}_o + \delta \dt{i_L}, \hspace{1cm}
  \dt{v}_C = {\dt{v}_C}_o + \delta \dt{v}_C
\end{align} Essa decomposição facilita a análise da estabilidade do ponto de equilíbrio $P_o$ e a obtenção de respostas lineares no entorno do ponto de equilíbrio.

% Transladação: regime permanente 
Sob condições de operação em regime permanente, em ambos os sistemas, no ponto de operação, a corrente do indutor e a tensão do capacitor são nulos, ou seja: \begin{equation} {i_L}_o = 0, \hspace{1cm} {v_C}_o = 0. \label{eq:translation_null}\end{equation} Com base nisso, pode-se obter as equações transladadas da corrente do indutor e da tensão do capacitor nos sistemas dinâmicos obtidos. Substituindo a relação descrita em \eqref{eq:translation_null} na equação da corrente $i_L$ no sistema dinâmico \eqref{eq:buck_nonlinear_system} no ponto de equilíbrio $P_o$, obtém-se: \begin{gather}
  - \frac{R_L}{L} {i_L}_o - \frac{1}{L} {v_C}_o + \frac{v_{in}}{L}  d_o = 0  \notag \\[12pt]
  - R_L {i_L}_o - {v_C}_o + v_{in}  d_o = 0 \notag \\[12pt]
  d_o = \frac{R_L}{v_{in}} {i_L}_o + \frac{{v_C}_o}{v_{in}} \label{eq:tranlation_buck_d_op}
\end{gather} Dado os valores da corrente do indutor e da tensão do capacitor, ambos no ponto de operação, é possível determinar o valor de operação do duty cycle $d_o$ por meio da relação expressa em \eqref{eq:tranlation_buck_d_op}. Substituindo as variáveis decompostas apresentadas em \eqref{eq:tranlation_decomposed_states} e \eqref{eq:tranlation_decomposed_inputs} na equação da corrente do $\dt{i}_L$ do primeiro sistema, obtém-se a sua forma transladada: \begin{gather}
  {\dot{i_L}}_o + \delta \dot{i_L}_ = - \frac{R_L}{L} \left({i_L}_o + \delta i_L(t)\right) - \frac{1}{L} \left({v_C}_o + \delta v_C(t)\right) + \frac{v_{in}}{L} \left(d_o + \delta d(t)\right) \notag\\[12pt]
  \delta \dot{i_L} = - \frac{R_L}{L} {i_L}_o - \frac{R_L}{L} \delta i_L - \frac{1}{L} {v_C}_o - \frac{1}{L} \delta v_C + \frac{v_{in}}{L} d_o + \frac{v_{in}}{L} \delta d \label{eq:translation_buck_current}
\end{gather} Por meio da relação expressa em \eqref{eq:tranlation_buck_d_op}, a equação \eqref{eq:translation_buck_current} pode ser simplificada como demonstrado a seguir: \begin{gather}
  \delta \dot{i_L} = - \frac{R_L}{L} {i_L}_o - \frac{R_L}{L} \delta i_L - \frac{1}{L} {v_C}_o - \frac{1}{L} \delta v_C +  \frac{R_L}{L} {i_L}_o + \frac{1}{L} {v_C}_o + \frac{v_{in}}{L} \delta d \notag \\[12pt]
  \delta \dot{i_L} = - \frac{R_L}{L} \delta i_L - \frac{1}{L} \delta v_C  + \frac{v_{in}}{L} \delta d \label{eq:translation_buck_current_simplified}
\end{gather}

Da mesma forma, a fim de transpor a equação de tensão do capacitor $\dt{v}_C$ do primeiro sistema \eqref{eq:buck_converter_voltage}, foi realizada uma análise no ponto de operação $P_o$, resultando na seguinte relação: \begin{gather}
  - \frac{1}{C R_C} {v_C}_o + \frac{1}{C} {i_L}_o - \frac{1}{C {v_C}_o} {P_{CPL}}_o = 0 \notag \\[12pt]
  - \frac{1}{R_C} {v_C}_o + {i_L}_o - \frac{1}{{v_C}_o} {P_{CPL}}_o = 0 \notag
\end{gather} \begin{equation}{i_L}_o = \frac{1}{R_C} {v_C}_o + \frac{1}{{v_C}_o} {P_{CPL}}_o \label{eq:translation_buck_iL_op}\end{equation} Assim, dado os valores da tensão de capacitor e a potência \acrshort{cpl}, ambos no ponto de operação, é possível determinar a corrente do indutor no ponto de operação por meio da relação obtida expressa em \eqref{eq:translation_buck_iL_op}. Substituindo as variáveis decompostas definidas em \eqref{eq:tranlation_decomposed_states} e \eqref{eq:tranlation_decomposed_inputs} na equação da tensão do capacitor do primeiro sistema \eqref{eq:buck_converter_voltage}, obtém-se: \begin{equation}
  \delta \dt{v}_C = - \frac{1}{C R_C} {v_C}_o - \frac{1}{C R_C} \delta v_C + \frac{1}{C} {i_L}_o + \frac{1}{C}  \delta i_L - \frac{1}{C \left({v_C}_o + \delta v_C\right)} \left({P_{cpl}}_o + \delta P_{cpl}\right) \label{eq:translation_buck_voltage}
\end{equation} Por meio da relação obtida expressa em \eqref{eq:translation_buck_iL_op}, a equação \eqref{eq:translation_buck_voltage} pode ser simplificada como demonstrado a seguir: \begin{gather}
  \delta \dt{v}_C = - \frac{1}{C R_C} {v_C}_o - \frac{1}{C R_C} \delta v_C + \frac{1}{C} \left(\frac{{v_C}_o}{R_C} + \frac{{P_{cpl}}_o}{{v_C}_o}\right) + \frac{1}{C}  \delta i_L - \frac{{P_{cpl}}_o + \delta P_{cpl}}{C \left({v_C}_o + \delta v_C\right)} \notag \\[12pt]
  \delta \dt{v}_C = - \frac{1}{C R_C} \delta v_C + \frac{1}{C {v_C}_o} {P_{cpl}}_o + \frac{1}{C}  \delta i_L - \frac{1}{C \left({v_C}_o + \delta v_C\right)} \left({P_{cpl}}_o + \delta P_{cpl}\right) \notag \\[12pt]
  \delta \dt{v}_C = - \frac{1}{C R_C} \delta v_C  + \frac{1}{C}  \delta i_L + \frac{{P_{cpl}}_o \delta v_C - {v_C}_o \delta P_{cpl}}{C {v_C}_o \left({v_C}_o + \delta v_C\right)}
\end{gather}

Portanto, o sistema transladado do primeiro sistema, em torno do ponto de operação $P_o$, é: \begin{equation}
  \begin{cases}
    \displaystyle \delta \dot{i_L} = - \frac{R_L}{L} \delta i_L - \frac{1}{L} \delta v_C  + \frac{v_{in}}{L} \delta d \\[12pt]
    \displaystyle \delta \dt{v}_C = - \frac{1}{C R_C} \delta v_C  + \frac{1}{C}  \delta i_L + \frac{{P_{cpl}}_o \delta v_C - {v_C}_o \delta P_{cpl}}{C {v_C}_o \left({v_C}_o + \delta v_C\right)}
  \end{cases}
\end{equation}

Do mesmo modo que foi realizado o processo de translação para o primeiro sistema, o mesmo foi aplicado ao segundo sistema \eqref{eq:boost_nonlinear_system}. No ponto de operação $P_o$, pode-se obter a seguinte relação: \begin{gather}
  - \frac{1 - d_o}{L}{v_C}_o + \frac{1}{L}v_{in} = 0 \notag \\[12pt]
  {d}_o = 1 - \frac{v_{in}}{{v_C}_o} \label{eq:translation_boost_d_op},
\end{gather} Logo, por meio desta relação, é possível determinar o duty cycle no ponto de operação dado o valor da tensão do capacitor também no ponto de operação. Reescrevendo a equação da corrente do segundo sistema, expressa em \eqref{eq:boost_converter_current}, substituindo as variáveis descritas em \eqref{eq:tranlation_decomposed_states} e \eqref{eq:tranlation_decomposed_inputs}, obtém-se: \begin{gather}
  \dt{\delta i_L}  = - \frac{1 - (d_o + \delta d) }{L} ({v_C}_o + \delta v_C) + \frac{1}{L} v_{in} \label{eq:translation_boost_current}
\end{gather} Substituindo a relação \eqref{eq:translation_boost_d_op} na equação \eqref{eq:translation_boost_current}, pode-se obter a sua forma simplificada: \begin{gather}
  \dt{\delta i_L}  = - \frac{1 - (1 - \displaystyle \frac{v_{in}}{{v_C}_o} + \delta d) }{L} ({v_C}_o + \delta v_C) + \frac{1}{L} v_{in} \notag  \\[12pt]
  \dt{\delta i_L}  = - \frac{\displaystyle \frac{v_{in}}{{v_C}_o} - \delta d }{L} ({v_C}_o + \delta v_C) + \frac{1}{L} v_{in} \notag  \\[12pt]
  \dt{\delta i_L}  = - \frac{v_{in}}{L{v_C}_o}\delta v_C + \left(\frac{{v_C}_o + \delta {v_C}}{L}\right) \delta d
\end{gather}

No ponto de operação $P_o$ do segundo sistema, da equação que descreve a tensão do capacitor $\dt{v}_C$, expressa em \eqref{eq:boost_converter_voltage}, pode-se obter a próxima relação do segundo sistema: \begin{gather}
  0 = \frac{1 - d_o}{C} {i_L}_o - \frac{1}{RC}{v_C}_o - \frac{1}{C{v_C}_o}{P_{cpl}}_o \notag \\[12pt]
  (1 - d_o){i_L}_o - \frac{1}{R}{v_C}_o - \frac{1}{{v_C}_o}{P_{cpl}}_o = 0 \notag \\[12pt]
  {i_L}_o = \frac{{v_C}_o}{R(1-d_o)} + \frac{{P_{cpl}}_o}{{v_C}_o (1 - d_o)} \notag \\[12pt]
  {i_L}_o = \frac{{v_C}^2_o + R{P_{cpl}}_o}{R{v_C}_o(1 - d_o)}
\end{gather} Por meio da relação \eqref{eq:translation_boost_d_op}, a equação anterior pode ser simplificada para: \begin{equation}
  {i_L}_o = \frac{{v_C}^2_o + R{P_{cpl}}_o}{R{v_{in}}}
  \label{eq:translation_boost_iL_op}
\end{equation} Dessa forma, tendo a tensão do capacitor e a potência da \acrshort{cpl} no ponto de operação, é possível determinar a corrente nesse ponto, utilizando a relação estabelecida em \eqref{eq:translation_boost_iL_op}. Por fim, ao realizar as substituições das variáveis decompostas conforme definidas em \eqref{eq:tranlation_decomposed_inputs} e \eqref{eq:tranlation_decomposed_states}, é obtida a forma transladada da equação da tensão $\dt{v}_C$ do segundo sistema definida em \eqref{eq:boost_converter_voltage}: \begin{gather}
  {{\dt{v}_C}}_o + \dt{\delta {v}_C} = \frac{1 - (d_o + \delta d)}{C} ( {i_L}_o + \delta i_L) - \frac{{v_C}_o + \delta v_C}{RC} - \frac{{{P_{cpl}}_o + \delta P_{cpl}}}{C({v_C}_o + \delta {v_C})}
\end{gather}

Simplificando por meio das relações expressas em \eqref{eq:translation_boost_d_op} e \eqref{eq:translation_boost_iL_op}, obtém-se: \begin{gather}
  \dt{\delta {v}_C} = \left( \frac{1 - d_o}{C} - \frac{\delta d}{C} \right)\left({i_L}_o + \delta i_L\right) - \frac{{v_C}_o + \delta v_C}{RC} - \frac{{{P_{cpl}}_o + \delta P_{cpl}}}{C({v_C}_o + \delta {v_C})}
\end{gather}

\subsection{Linearização dos modelos obtidos}

% Linearização - introdução
Por causa da presença de não linearidades em ambos os modelos, \eqref{eq:buck_nonlinear_system} e \eqref{eq:boost_nonlinear_system}, eles são intrinsecamente não lineares. Para abordar essa não linearidade, pode-se linearizá-los, obtendo um conjunto de equações que descrevem pequenas mudanças em torno do ponto de equilíbrio $P_{\text{eq}}$ nos estados dos sistemas, $i_L(t)$ e $v_C(t)$.

% Linearização - sistema linearizado genérico
A linearização é feita por meio da aproximação de primeira ordem da série de Taylor em torno do ponto de equilíbrio $P_{\text{eq}} = ({i_L}_{\text{eq}}, \, {v_C}_{\text{eq}}, \, {d}_{\text{eq}}, \, {P_{CPL}}_{\text{eq}})$, conforme descrito a seguir: \begin{gather}  \dt{\delta i_L} = \frac{\partial \dt{i}_L}{\partial i_L}\delta i_L(t) + \frac{\partial \dt{i}_L}{\partial v_C}\delta v_C(t) + \frac{\partial {\dt{i}_L}}{\partial d}\delta d(t) + \frac{\partial {\dt{i}_L}}{\partial P_{CPL}}\delta P_{CPL}(t) \\ \nonumber \\ \dt{\delta v_C} = \frac{\partial \dt{v}_C}{\partial i_L}\delta i_L(t) + \frac{\partial \dt{v}_C}{\partial v_C}\delta v_C(t) + \frac{\partial \dt{v}_C}{\partial d}\delta d(t) + \frac{\partial \dt{v}_C}{\partial P_{CPL}}\delta P_{CPL}(t), \end{gather} onde, o símbolo $\delta$ indica a variação da variável em relação ao ponto de equilíbrio, isto é, \begin{equation} \delta f(t) = f(t) - f_{\text{op}}. \label{eq:delta}\end{equation}

% Linearização - conversor buck
A partir dessas equações, podemos derivar as expressões linearizadas de $\dt{i}_L$ e $\dt{v}_C$ para o primeiro sistema, como mostrado abaixo: \begin{equation} \begin{cases} \delta \dt{i}_L &= -\frac{R_L}{L} \delta i_L(t) - \frac{1}{L} \delta v_C(t) + \frac{v_{\text{in}}}{L} \delta d(t) \\ \delta \dt{v}_C &= \frac{1}{C} \delta i_L(t) + \frac{1}{C} \left(\frac{{P_{CPL}}_{\text{eq}}}{{v_C}^2_{\text{eq}}} - \frac{1}{R_C}\right) \delta v_C(t) - \frac{1}{C{v_C}_{\text{eq}}} \delta P_{CPL}(t), \end{cases} \end{equation} ou, na forma de espaço de estados: \begin{equation} \begin{bmatrix} \dt{\delta i_L} \\ \dt{\delta v_C} \end{bmatrix} = \begin{bmatrix} \displaystyle -\frac{R_L}{L} & \displaystyle -\frac{1}{L}  \\\\ \displaystyle \frac{1}{C} & \displaystyle \frac{1}{C}\left(\frac{{P_{CPL}}_{\text{eq}}}{{{v_{C}}^2_{\text{eq}}}} - \frac{1}{R_C}\right) \end{bmatrix} \begin{bmatrix} \delta i_L(t) \\ \delta v_C(t) \end{bmatrix} + \begin{bmatrix} {\displaystyle \frac{v_{in}}{L}} & 0 \\ \\ 0 & \displaystyle {-\frac{1}{C{v_C}_{\text{eq}}}} \end{bmatrix}  \begin{bmatrix} \delta d(t) \\ \delta P_{CPL}(t) \end{bmatrix}. \label{eq:buck_linear_system}\end{equation}

Para o segundo modelo dinâmico \eqref{eq:boost_nonlinear_system}, têm-se: \begin{equation} \begin{cases} \delta \dt{i}_L &= - \frac{1 - d_{\text{eq}}}{L} \delta v_C(t) + \frac{{v_C}_{\text{eq}}}{L}\delta d(t) \\ \delta \dt{v}_C &= \frac{1 - d_{\text{eq}}}{C} \delta i_L(t) + \frac{1}{C} \left(\frac{{P_{CPL}}_{\text{eq}}}{{v_C}^2_{\text{eq}}} - \frac{1}{R}\right) \delta v_C(t) - \frac{{i_L}_{\text{eq}}}{C} \delta d(t) - \frac{1}{C{v_C}_{\text{eq}}} \delta P_{CPL}(t), \end{cases} \end{equation} ou, expresso na forma de espaço de estados: \begin{equation} \begin{bmatrix} \dt{\delta i_L} \\ \dt{\delta v_C} \end{bmatrix} = \begin{bmatrix} \displaystyle 0 & \displaystyle -\frac{1 - d_{\text{eq}}}{L}  \\\\ \displaystyle \frac{1 - d_{\text{eq}}}{C} & \displaystyle \frac{1}{C}\left(\frac{{P_{CPL}}_{\text{eq}}}{{{v_{C}}^2_{\text{eq}}}} - \frac{1}{R}\right) \end{bmatrix} \begin{bmatrix} \delta i_L(t) \\ \delta v_C(t) \end{bmatrix} + \begin{bmatrix} {\displaystyle \frac{{v_C}_{\text{eq}}}{L}} & 0 \\ \\ - \frac{{i_L}_{\text{eq}}}{C} & \displaystyle {-\frac{1}{C{v_C}_{\text{eq}}}} \end{bmatrix}  \begin{bmatrix} \delta d(t) \\ \delta P_{CPL}(t) \end{bmatrix}. \label{eq:boost_linear_system}\end{equation}

\section{Simulação}

% Introdução
Nesta seção, apresenta-se a simulação de dois conversores utilizando a linguagem de programação Python e bibliotecas específicas. O pacote \textit{Python Control Systems Library} é utilizado para simular os sistemas dinâmicos, enquanto o CVXPY resolve os problemas de otimização por \acrshortpl{lmi} para determinar os parâmetros de projeto do \acrshort{etm}. O NumPy é utilizado para a computação científica e o Matplotlib para a visualização dos resultados. Os modelos são simulados e o desempenho sob o \acrshort{etc} em diferentes cenários e condições de operação são obtidos.

\subsection{Parâmetros dos Conversores \acrshort{cc}-\acrshort{cc}}

A variável \texttt{params} é um dicionário que contém os parâmetros do conversor. Para diferentes valores desses parâmetros do circuito, os conversores apresentarão comportamentos distintos. No conversor Buck, os parâmetros são a tensão de entrada (\texttt{Vin}), as resistências (\texttt{rL} e \texttt{rC}), a indutância (\texttt{L}), a capacitância (\texttt{C}), a potência da CPL e a tensão desejada do capacitor (\texttt{Pcpl} e \texttt{vC}). Em seguida, são calculadas a corrente do indutor (\texttt{iL}) e o ciclo de trabalho (\texttt{d}) no ponto de operação, de acordo com as relações expressas em \eqref{eq:translation_buck_iL_op} e \eqref{eq:tranlation_buck_d_op}, respectivamente, para o conversor Buck. Com esses valores do ponto de operação, as entradas \texttt{U\_OP} e os estados \texttt{X\_OP} são definidos. Além disso, a entrada do sistema (\texttt{U}) é definida como os valores no ponto de operação, enquanto os estados iniciais (\texttt{X0}) são definidos como 95\% dos valores no ponto de operação. Por fim, são calculadas as variações nas entradas (\(\delta U\)) e nos estados iniciais ($\delta X0$) em relação ao ponto de operação. A definição completa dos parâmetros do conversor Buck está implementada no código a seguir: 

\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Parâmetros do conversor Buck.}, label=cod:buck_params]
  # Parâmetros do Circuito
  params = {'Vin': 48, 'rL': 0.1, 'rC': 35,
            'L': 40e-3, 'C': 10e-6, 'op': {'Pcpl': 15, 'vC': 24}}

  # Cálculo da Corrente e Duty Cycle de Operação
  op = params['op']
  IL_OP = (op['vC'] / params['rC']) + op['Pcpl'] / op['vC']
  D_OP = (params['rL'] * IL_OP) / params['Vin'] + op['vC'] / params['Vin']

  params['op']['iL'] = IL_OP
  params['op']['d'] = D_OP

  # Ponto de operação de cada entrada e estado do sistema
  U_OP = np.array([params['op']['d'], params['op']['Pcpl']])
  X_OP = np.array([params['op']['iL'], params['op']['vC']])

  # Entradas do Sistema
  D = params['op']['d']
  P_CPL = params['op']['Pcpl']
  U = np.array([D, P_CPL])

  # Estados Iniciais do Sistema
  IL_INIT = 0.95 * params['op']['iL']
  VC_INIT = 0.95 * params['op']['vC']
  X0 = np.array([IL_INIT, VC_INIT])

  δU = U - U_OP
  δX0 = X0 - X_OP
\end{lstlisting}

No caso do conversor Boost, cuja implementação está no código \ref{cod:boost_params}, os valores da tensão de entrada (\texttt{Vin}), resistência (\texttt{R}), indutância (\texttt{L}), capacitância (\texttt{C}), potência da CPL e tensão desejada do capacitor (\texttt{Pcpl} e \texttt{vC}) são inicialmente definidos. A corrente do indutor e o duty cycle no ponto de operação são obtidos usando as equações \eqref{eq:translation_boost_iL_op} e \eqref{eq:translation_boost_d_op} e, por meio destes valores, as entradas (\texttt{U\_OP}) e os estados (\texttt{X\_OP}) são definidos. A entrada do sistema (\texttt{U}) é ajustada para os valores do ponto de operação, enquanto os estados iniciais (\texttt{X0}) são definidos como 95\% dos valores no ponto de operação. Variações nas entradas (\(\delta U\)) e nos estados iniciais ($\delta X0$) em relação ao ponto de operação são então calculadas.
\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Parâmetros do conversor Boost.}, label=cod:boost_params]
  params = {'Vin': 48, 'R': 50, 'L': 50e-3,
          'C': 800e-6, 'op': {'Pcpl': 300, 'vC': 96}}

  # Cálculo da Corrente e Duty Cycle de Operação
  op = params['op']
  IL_OP = (op['vC'] ** 2 + params['R'] * op['Pcpl']) / \
      (params['R'] * params['Vin'])
  D_OP = 1 - params['Vin'] / op['vC']

  params['op']['iL'] = IL_OP
  params['op']['d'] = D_OP

  # Ponto de operação de cada entrada e estado do sistema
  U_OP = np.array([params['op']['d'], params['op']['Pcpl']])
  X_OP = np.array([params['op']['iL'], params['op']['vC']])

  # # Entradas do Sistema
  D = params['op']['d']
  P_CPL = params['op']['Pcpl']
  U = np.array([D, P_CPL])

  # # Estados Iniciais do Sistema
  IL_INIT = 0.95 * params['op']['iL']
  VC_INIT = 0.95 * params['op']['vC']
  X0 = np.array([IL_INIT, VC_INIT])

  δU = U - U_OP
  δX0 = X0 - X_OP
\end{lstlisting}

\subsection{Implementação dos Conversores \acrshort{cc}-\acrshort{cc}}

% Implementação do Buck não linear
No código \ref{cod:buck_nonlinear}, a função \texttt{update\_buck\_nonlinear} define o comportamento dinâmico do conversor buck não linear expressa em \eqref{eq:buck_nonlinear_system}. Ela recebe como entrada o tempo \texttt{t}, os estados do sistema \texttt{x}, as entradas do sistema \texttt{u} e os parâmetros do sistema \texttt{params}. A partir dessas informações, a função calcula as derivadas dos estados do sistema, que representam as mudanças da corrente do indutor \texttt{diL} e da tensão do capacitor \texttt{dvC}. A função \texttt{output\_buck\_nonlinear} define quais variáveis do sistema serão consideradas como saídas e recebe os mesmos parâmetros da função de atualização dos estados. Assim, a função retorna um vetor com as variáveis de interesse, neste caso, a corrente do indutor \texttt{iL} e a tensão do capacitor \texttt{vC}. Por fim, a variável \texttt{nonlinear\_system} define um sistema de tempo contínuo por meio da função (\texttt{ct.ss}) da biblioteca \textit{Python Control} utilizando as funções atualização e a função de saídas definidas anteriormente.
\vspace{8pt}

\begin{lstlisting}[language=Python, caption={Implementação do conversor Buck não linear.}, label=cod:buck_nonlinear]
def update_buck_nonlinear(t, x, u, params):
  # Parâmetros do sistema
  V_IN = params.get('Vin')  # Tensão de Entrada
  RL = params.get('rL')     # Resistência (indutor)
  RC = params.get('rC')     # Resistência (capacitor)
  L = params.get('L')       # Indutância
  C = params.get('C')       # Capacitância

  # Entradas do sistema: Duty Cycle e Potência da CPL
  D, P_CPL = u

  # Estados do sistema: corrente do indutor e tensão do capacitor
  IL, VC = x

  # Atualização da corrente do indutor
  diL = (V_IN / L) * D - (RL / L) * IL - VC / L  

  # Atualização da tensão do capacitor   
  dvC = IL / C - VC / (C * RC) - P_CPL / (C * VC)

  dx = np.array([diL, dvC])
  return dx

# Definição da saída do sistema
def output_buck_nonlinear(t, x, u, params):
  return x[0:2]

# Definição do conversor cc-cc buck nao-linear
buck_nonlinear = ct.ss(
  update_buck_nonlinear, 
  output_buck_nonlinear,
  name='buck_nonlinear',
  inputs=('d', 'P_cpl'),
  outputs=('iL', 'vC'),
  states=('iL', 'vC')
)
\end{lstlisting}

Assim como a implementação do conversor Buck, as funções de atualização e saída foram desenvolvidas para o conversor Boost, conforme definido em \eqref{eq:boost_nonlinear_system}. O código de implementação do conversor Boost, representado por \texttt{boost\_nonlinear}, é apresentado a seguir:
\vspace{8pt}

\begin{lstlisting}[language=Python, caption={Implementação do conversor Boost não linear.}, label=cod:boost_nonlinear]
  def update_boost_nonlinear(t, x, u, params):
  # Definição dos parâmetros do sistema
  V_IN = params.get('Vin')  # Tensão de Entrada
  R = params.get('R')       # Resistência (indutor)
  L = params.get('L')       # Indutância
  C = params.get('C')       # Capacitância

  # Entradas do sistema: Duty Cycle e Potência da CPL
  D, P_CPL = u

  # Estados do sistema: corrente do indutor e tensão do capacitor
  IL, VC = x

  # Atualização da corrente do indutor
  dIl = - ((1. - D) / L) * VC + (V_IN / L)
  
  # Atualização da tensão do capacitor
  dVc = ((1. - D) * IL) / C - VC / (R * C) - P_CPL / (C * VC)

  dx = np.array([dIl, dVc])
  return dx

# Definição da saída do sistema
def output_boost_nonlinear(t, x, u, params):
  return x[0:2]

# Definição do conversor cc-cc boost nao-linear
boost_nonlinear = ct.ss(
    update_boost_nonlinear, 
    output_boost_nonlinear,
    name='boost_nonlinear',
    inputs=('d', 'P_cpl'),
    outputs=('iL', 'vC'),
    states=('iL', 'vC')
)
\end{lstlisting}

\subsection{Implementação dos Modelos Linearizados} \label{subsection:implementation_of_linear_models}

O código \ref{cod:buck_linear} implementa a linearização do conversor buck em torno do ponto de operação $P_o$ definido em \eqref{eq:operation_point}. A variável \texttt{OP} armazena os valores de $P_o$ contida no dicionário \texttt{params} e, portanto, representa o ponto de operação do conversor. Em seguida, são construídas as matrizes de estado \texttt{A}, de entrada \texttt{B}, de saída \texttt{C} e de alimentação \texttt{D} do sistema, de acordo com a linearização do conversor Buck definida em \eqref{eq:buck_linear_system}. Por último, a variável \texttt{buck\_linearized} é criada por meio da transformação do sistema linear, construído com base nas matrizes do sistema, para sua forma de representação entrada-saída. Isso é feito para aumentar a flexibilidade da simulação, permitindo a definição de tags para as entradas, saídas e estados, o que facilita a interconexão entre os sistemas.

\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Implementação do conversor Buck linearizado.}, label=cod:buck_linear]
  # Obtenção dos valores no ponto de operação (OP)
  OP = params['op']

  # Elementos da matriz de estados
  A11 = - (params['rL'] / params['L'])
  A12 = - (1. / params['L'])
  A21 = 1. / params['C']
  A22 = (1. / params['C']) * (OP['Pcpl'] /
        (OP['vC'] * OP['vC']) - 1. / params['rC'])

  # Elementos da matriz de entrada
  B11 = params['Vin'] / params['L']
  B12 = 0.
  B21 = 0.
  B22 = - 1.0 / (params['C'] * OP['vC'])

  # Matriz de estados: iL e vC
  A = [[A11, A12], [A21, A22]]

  # Matriz de entradas: d e P_cpl
  B = [[B11, B12], [B21, B22]]

  # Matriz de saída: iL e vC
  C = [[1., 0], [0., 1]]

  # Matriz de alimentação: nula
  D = [[0., 0.], [0., 0.]]

  buck_linearized = ct.ss2io(
    ss(A, B, C, D),
    name='buck_linearized',
    inputs=('δd', 'δPcpl'),
    outputs=('δiL', 'δvC'),
    states=('δiL', 'δvC')
  )
\end{lstlisting}

Da mesma forma que foi implementada a linearização do conversor Buck em torno do ponto de operação definido, o código a seguir aborda a linearização do conversor Boost. O ponto de operação $P_o$, como definido em \eqref{eq:operation_point}, é armazenado na variável \texttt{OP}, extraída do dicionário \texttt{params}. A construção das matrizes de estado (\texttt{A}), de entrada (\texttt{B}), de saída (\texttt{C}), e de alimentação (\texttt{D}) segue o mesmo processo utilizado para o conversor Buck, conforme definido em \eqref{eq:boost_linear_system}. E assim, a variável \texttt{boost\_linearized} é criada para representar o conversor Boost linearizado.

\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Implementação do conversor Boost linearizado.}, label=cod:boost_linear]
  # Obtenção dos valores no ponto de operação (OP)
  OP = params['op']
  
  # Elementos da matriz de estados
  A11 = 0.
  A12 = - ((1. - OP['d']) / params['L'])
  A21 = (1. - OP['d']) / params['C']
  A22 = (1. / params['C']) * \
      ((OP['Pcpl'] / (OP['vC'] ** 2)) - (1. / params['R']))
  
  # Elementos da matriz de entrada
  B21 = - (OP['iL'] / params['C'])
  B22 = - 1. / (params['C'] * OP['vC'])
  B11 = OP['vC'] / params['L']
  B12 = 0.
  
  # Matriz de estados: iL e vC
  A = [[A11, A12], [A21, A22]]
  
  # Matriz de entradas: d e P_cpl
  B = [[B11, B12], [B21, B22]]
  
  # Matriz de saída: iL e vC
  C = [[1., 0], [0., 1]]
  
  # Matriz de alimentação: nula
  D = [[0., 0.], [0., 0.]]
  
  boost_linearized = ct.ss2io(
      ss(A, B, C, D),
      name='linearized_system',
      inputs=('δd', 'δPcpl'),
      outputs=('δIl', 'δVc'),
      states=('δIl', 'δVc')
  )
\end{lstlisting}

\subsection{Obtenção dos Parâmetros de Projeto do \acrshort{etm}}

O código \ref{cod:params_etm} aborda a resolução do problema de minimização estabelecido em \eqref{eq:optimization_problem} que busca aumentar o intervalo de tempo entre os eventos. Através desta abordagem, busca-se determinar os valores ótimos dos parâmetros $\Xi$ e $\Psi$, que são essenciais para determinar o momento de acionamento de um evento, além do ganho $K$ utilizado no controle em malha fechada.

\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Resolução do problema de otimização definida em \eqref{eq:optimization_problem}.}, label=cod:params_etm]
  # Definição dos parâmetros do problema de otimização
  A = cp.Parameter((2, 2),
                   value=np.array([[A11, A12], [A21, A22]]))
  BU = cp.Parameter((2, 1), value=np.array([[B11], [B21]]))
  I = cp.Parameter((2, 2), name='I', value=np.identity(2))
  
  # Definição das variáveis do problema de otimização
  Q = cp.Variable((2, 2), name='Q', PSD=True)
  X = cp.Variable((2, 2), name='X', PSD=True)
  Ξ_TIL = cp.Variable((2, 2), name='Ξ_TIL', PSD=True)
  Ψ_TIL = cp.Variable((2, 2), name='Ψ_TIL', PSD=True)
  K_TIL = cp.Variable((1, 2), name='K_TIL')
  
  # Definição do problema: objetivo e restrições
  obj = cp.Minimize(cp.trace(Ξ_TIL + Ψ_TIL + Q))
  
  M11 = A @ X + BU @ K_TIL + X @ A.T + K_TIL.T @ BU.T
  M12 = BU @ K_TIL
  M13 = X
  
  M21 = K_TIL.T @ BU.T
  M22 = -Ξ_TIL
  M23 = np.zeros(shape=(2, 2))
  
  M31 = X
  M32 = np.zeros(shape=(2, 2))
  M33 = -Ψ_TIL
  
  M = cp.bmat([[M11, M12, M13],
               [M21, M22, M23],
               [M31, M32, M33]])
  
  N11 = -Q
  N12 = I
  N21 = I.T
  N22 = -X
  N = cp.bmat([[N11, N12],
               [N21, N22]])
  
  constraints = [M << 0, N << 0]
  prob = cp.Problem(obj, constraints)
  
  # Resolução do problema usando o solver MOSEK
  prob.solve(solver=cp.MOSEK, verbose=False)
  
  K = None
  Ξ = None
  Ψ = None
  P = None
  
  # Apresentação dos Resultados
  if prob.status not in ["infeasible", "unbounded"]:
    X_INV = np.linalg.inv(X.value)
    Ξ = X_INV @ Ξ_TIL.value @ X_INV
  
    _K = K_TIL @ X_INV
    K = _K.value
  
    Ψ = np.linalg.inv(Ψ_TIL.value)
    P = X_INV
\end{lstlisting}

Inicialmente, são estabelecidos os parâmetros do problema de otimização, em que \texttt{A} representa a matriz de estados e \texttt{BU}, a matriz de entrada controlável, isto é, o duty cycle. Ambas são formadas utilizando os elementos previamente definidos na subseção anterior, \ref{subsection:implementation_of_linear_models}. Além disso, é definida a matriz identidade $I_2$, representada por \texttt{I}, uma vez que tanto o sistema Buck quanto o Boost possuem dois estados. Em seguida, as variáveis do problema são definidas. São elas: $Q$, $X$, $\tilde{\Xi}$, $\tilde{\Psi}$, todas matrizes semidefinidas positivas indicadas por \texttt{PSD=True}, e $\tilde{K}$, conforme definido em \eqref{eq:optimization_problem}.

Após a definição dos parâmetros e das variáveis do problema, o objetivo, representado por \texttt{obj}, é estabelecido. Ele é construído utilizando a função \texttt{Minimize} da biblioteca CVXPY, indicando que se trata de um problema de minimização. Como argumento, esta função recebe o que deve ser minimizado, sendo o traço da soma das matrizes $\tilde{\Xi}$, $\tilde{\Psi}$ e $Q$, como definido em \eqref{eq:optimization_problem}. O traço é calculado através da função \texttt{trace}, também da biblioteca CVXPY. Logo após, as restrições do problema são definidas, onde a variável \texttt{M} representa a \acrshort{lmi} de restrição conforme \eqref{eq:constraints_1}, e \texttt{N} representa a segunda \acrshort{lmi} de restrição, como definido em \eqref{eq:constraints_2}. Ambas são construídas utilizando a função \texttt{bmat} do CVXPY, que gera blocos de matrizes. O operador \texttt{<<}, pertencente à biblioteca CVXPY, indica que as matrizes são semidefinidas negativas, conforme determinado nas \acrshortpl{lmi} de restrição.

Por fim, o problema é criado e representado por \texttt{prob}, utilizando a função \texttt{Problem}, que recebe dois parâmetros: o objetivo e as restrições previamente definidos. Em seguida, o problema é resolvido pelo solucionador MOSEK, utilizando o método \texttt{solve} da variável \texttt{prob}. Após a conclusão da resolução, é verificado se o problema é factível. Se for o caso, os parâmetros $\Psi$, $\Xi$, $K$ e $P$ do projeto do \acrshort{etm} são obtidos.

\subsection{Implementação dos Sistemas em Loop Fechado sob \acrshort{etc}}

% A implementação do sistema Buck em loop fechado sob o ETC é detalhada no código \ref{cod:closed_loop_buck}. Neste sistema, é realizada a interconexão entre a planta (conversor Buck), o ETM, o ZOH e o controlador, conforme apresentado na subseção \ref{subsection:etc}.

A partir dos parâmetros derivados da solução do problema de otimização discutido na seção anterior, é implementado o \acrshort{etm} estático, cujo código está apresentado em \ref{cod:static_etm}. Este possui quatro entradas, das quais as duas primeiras são os últimos estados enviados $\hat{x}$ provenientes do ZOH e os estados atuais $x$ obtidos da planta. Suas saídas consistem em $\Gamma$, uma variável booleana que, quando verdadeira, aciona um evento, e os estados atuais da planta. Essas saídas são determinadas pela função \texttt{etm\_output}, a qual recebe como parâmetros o tempo atual da simulação, o estado atual do \acrshort{etm}, a entrada do \acrshort{etm} e os parâmetros do sistema, respectivamente.

Internamente, a função verifica o início da segunda simulação. Isso se deve ao fato de que a simulação é realizada duas vezes: a segunda vez com um passo de simulação maior e menos preciso. Esta distinção é crucial, pois o tempo de acionamento de eventos é registrado apenas na primeira simulação, que utiliza um passo de tempo menor e mais preciso. Além disso, o cálculo de $\Gamma$ é realizado, sendo este um valor real. Caso seja negativo, um novo evento deve ser acionado. Se isso ocorrer, os estados atuais serão definidos como a saída do \acrshort{etm}; caso contrário, serão os últimos estados enviados.

\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Implementação do \acrshort{etm} estático.}, label=cod:static_etm]
  zero = 0
  event_times = [0.]

  def get_gama(current_states, last_states_sent):
    error = last_states_sent - current_states
    return current_states.T @ Ψ @ current_states - error.T @ Ξ @ error


  def etm_output(t, x, u, params):
    global zero, event_times

    if t != etm_output.previous_time:
      etm_output.previous_time = t
      if etm_output.first_simulation and t == 0.:
        etm_output.first_simulation = False

    last_states_sent = u[0:2]
    current_states = u[2:4]

    Γ = get_gama(current_states, last_states_sent)
    trigger = Γ < 0

    if etm_output.first_simulation and trigger:
      event_times.append(t)

    state_to_sent = (current_states if trigger or t == 0. else last_states_sent)
    return [state_to_sent[0], state_to_sent[1]]

  etm_output.previous_time = 0
  etm_output.first_simulation = True

  ETM = ct.ss(
    None, etm_output,
    name='etm',
    inputs=('x1_hat', 'x2_hat', 'x1', 'x2'),
    outputs=('x1', 'x2'),
  )
\end{lstlisting}

No caso do \acrshort{etm} dinâmico, uma nova função, \texttt{etm\_update}, é criada. Esta função é responsável pela atualização da variável dinâmica $\eta$ do \acrshort{etm} dinâmico, conforme definido em \eqref{eq:dynamic-etm}. Na função de saída, a lei de acionamento é modificada para incorporar a versão dinâmica do \acrshort{etm}, conforme definido em \eqref{eq:etm-dynamic-trigger}. Além disso, uma nova saída do \acrshort{etm} é adicionada, representando a variável dinâmica do próprio \acrshort{etm}. Por fim, tanto a função de atualização quanto a saída do \acrshort{etm} dinâmico dependem dos parâmetros $\theta$ e $\epsilon$, que são previamente definidos.

\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Implementação do \acrshort{etm} dinâmico.}, label=cod:dynamic_etm]
  θ = 1.
  λ = .1
  
  def etm_update(t, n, u, params):
    Γ = get_gama(current_states=u[2:4], last_states_sent=u[0:2])
    dn = -λ * n + Γ
    return [dn]


  def etm_output(t, n, u, params):
    global zero, event_times

    if t != etm_output.previous_time:
      etm_output.previous_time = t
      if etm_output.first_simulation and t == 0.:
        etm_output.first_simulation = False

    last_states_sent = u[0:2]
    current_states = u[2:4]

    Γ = get_gama(current_states, last_states_sent)
    trigger = (n + θ * Γ) < 0

    if etm_output.first_simulation and trigger:
      event_times.append(t)

    state_to_sent = (current_states if trigger or t == 0. else last_states_sent)
    return [state_to_sent[0], state_to_sent[1], n[0]]


  etm_output.previous_time = 0
  etm_output.first_simulation = True

  ETM = ct.ss(
    etm_update, etm_output,
    name='etm',
    states=('n'),
    inputs=('x1_hat', 'x2_hat', 'x1', 'x2'),
    outputs=('x1', 'x2', 'n'),
  )
  \end{lstlisting}

O código \ref{cod:zoh} é a implementação do \acrshort{zoh}. Inicialmente, é definida uma função chamada \texttt{zoh\_output}, que implementa a saída do \acrshort{zoh} para o sistema de controle contínuo. O método de saída \acrshort{zoh} retém o valor de entrada atual até o próximo instante. A função armazena o estado anterior \texttt{previous} e o tempo anterior \texttt{previous\_time}. Em cada chamada, se o tempo atual \texttt{t} for diferente do tempo anteriormente armazenado, o estado anterior é atualizado e o tempo anterior é atualizado para \texttt{t}. A função retorna os estados previamente armazenados \texttt{last\_states\_sent} que é inicializada com os valores iniciais dos estados da planta.

\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Implementação do \acrshort{zoh}}, label=cod:zoh]
  def zoh_output(t, x, u, params):
    if t != zoh_output.previous_time:
      zoh_output.last_states_sent = zoh_output.previous
      zoh_output.previous_time = t
    zoh_output.previous = u
    return zoh_output.last_states_sent

  zoh_output.previous_time = 0
  zoh_output.second_simulation = False
  zoh_output.previous = []
  zoh_output.last_states_sent = δX0.tolist()

  ZOH = ct.ss(
    None, zoh_output,
    name='zoh',
    inputs=('x1', 'x2'),
    outputs=('x1_hat', 'x2_hat'),
  )
\end{lstlisting}

No código \ref{cod:controller}, é definida a função de saída do controlador, \texttt{control\_output}, responsável por implementar a operação de controle para a planta. Dentro dessa função, ocorre o cálculo do ciclo de trabalho, que consiste no produto escalar entre a matriz de ganho $K$ e os estados $\hat{x}$. Assim, a matriz de ganho representada pela variável \texttt{K} é aplicada aos estados representados por \texttt{u}, resultando no cálculo do ciclo de trabalho desejado. Este último é então retornado como saída do controlador. A seguir, é definido o sistema de controle \texttt{CONTROL}. Este sistema é estático (determinado por \texttt{None}) e utiliza a função \texttt{control\_output} como função de saída. O sistema conta com duas entradas, que correspondem aos estados provenientes do \acrshort{zoh}, e uma saída, que representa o ciclo de trabalho, entrada da planta.

\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Implementação do controlador.}, label=cod:controller]
  def control_output(t, x, u, params):
    duty_cycle = K @ u
    return [duty_cycle]


  CONTROL = ct.ss(
      None, control_output,
      name='control',
      inputs=('x1_hat', 'x2_hat'),
      outputs=('u'),
  )
\end{lstlisting}

O código \ref{cod:closed_loop} cria um sistema de controle em malha fechada para o conversor Buck sob o \acrshort{etc}. É utilizada a função \texttt{interconnect} para conectar os quatro subsistemas: o sistema linearizado do conversor buck, o \acrshort{etm}, o \acrshort{zoh}, e o controlador. As conexões entre esses componentes são especificadas para formar um loop de realimentação, conforme apresentado na subseção \ref{subsection:etc}. O sistema resultante é então nomeado como \texttt{closed\_loop\_buck\_system}, e suas entradas e saídas são definidas. Em seguida, define-se o tempo de simulação e o sinal de entrada, que neste caso é um sinal constante chamado \texttt{\ensuremath{\delta}Pcpl}, mas também pode ser um vetor contendo valores variados. Por fim, a função \texttt{input\_output\_response} é utilizada para simular a resposta do sistema fechado ao longo do tempo, armazenando as respostas do sistema em \texttt{t} (tempo) e \texttt{y} (saídas do sistema).

\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Sistema em loop fechado sob o ETC.}, label=cod:closed_loop]
  CLOSED_LOOP_BUCK_SYSTEM = ct.interconnect(
      (buck_linearized, ETM, ZOH, CONTROL),
      connections=(
          # Conexão entre a saída do controlador e a planta
          ('buck_linearized.δd', 'control.u'),

          # Conexão entre as saídas do ZOH e da planta ao ETM
          ('etm.x1_hat', 'zoh.x1_hat'),
          ('etm.x2_hat', 'zoh.x2_hat'),
          ('etm.x1', 'buck_linearized.δiL'),
          ('etm.x2', 'buck_linearized.δvC'),

          # Conexão da saída do ETM no ZOH
          ('zoh.x1', 'etm.x1'),
          ('zoh.x2', 'etm.x2'),

          # Conexão da saída do ZOH no controlador
          ('control.x1_hat', 'zoh.x1_hat'),
          ('control.x2_hat', 'zoh.x2_hat'),
      ),
      name='closed_loop_buck_system',
      inplist=('buck_linearized.δPcpl'),
      outlist=('buck_linearized.δiL',
              'buck_linearized.δvC',
              'etm.Γ',
              'buck_linearized.δd',
              ),
      output=('δiL', 'δvC', 'Γ', 'u')
  )

  print(CLOSED_LOOP_BUCK_SYSTEM)
  print('')

  step = 1e-6
  timepts = np.arange(0, 1. + step, step)

  # Simulação para a pertubação constante
  δPcpl = 0.

  # Simulação para a pertubação não constante
  # δPcpl = np.zeros_like(timepts)
  # δPcpl[np.where(timepts >= 0.3)] = 20
  # δPcpl[np.where(timepts >= 0.6)] = 30

  t, y = ct.input_output_response(
      sys=CLOSED_LOOP_BUCK_SYSTEM, T=timepts,
      U=δPcpl,
      X0=δX0,
      solve_ivp_method='RK45',
      solve_ivp_kwargs={'max_step': step}
  )
\end{lstlisting}

Por fim, o código simples abaixo tem como finalidade calcular os intervalos de tempo entre eventos consecutivos e armazená-los na variável \texttt{inter\_event\_times}, para análises futuras.

\vspace{8pt}
\begin{lstlisting}[language=Python, caption={Cálculo da intervalo entre eventos.}, label=cod:closed_loop]
  inter_event_times = []
  for i in range(1, len(event_times)):
    inter_event_times.append(event_times[i] - event_times[i-1])
\end{lstlisting}